# Libasm

![](https://github.com/gurugio/book_assembly_8086_ko/raw/master/assets/cpu.gif)
## 레지스터
- ax (acumulator): 적산하는 레지스터
- bx (base address):  메모리 주소 계산 레지스터
- cx (counter): 반복문 카운팅시 사용 (5번반복 -> 5, 4, 3, 2, 1)
- dx (data): 계산의 결과 값 저장 / 메모리에서 읽어온 데이터 저장
- si (source index): 메모리 복사 등에서 원본 데이터의 주소를 저장
- di (Destination Index): 메모리 복사 등에서 목적지의 주소를 저장
- bp (base pointer): 스택의 베이스 주소
- sp (stack pointer): 스택의 현재 주소

## 세그먼트 레지스터
- CS: 현재 프로그램이 저장된 세그먼트의 주소가 저장됩니다.

- DS: 현재 사용하는 데이터가 저장된 세그먼트의 주소가 저장됩니다.

- ES: 별도의 용도는 없고 필요할 때마다 원하는 메모리 위치의 세그먼트 주소를 저장합니다.

- SS: 스택이 있는 세그먼트의 주소가 저장됩니다.

## 플래그 레지스터
- Carry Flag (CF) - 부호없는 정수가 overflow일경우 플래그값은 1로 설정됩니다. 무슨 말이냐면 al에 255를 넣고 1을 더하는 연산을 하는 경우에 결과값이 범위가 8비트 범위 0 ~ 255를 넘게되고 이런 상태를 overflow라고 부릅니다. overflow가 아닌경우에는 플래그 값은 0으로 남아있습니다.

- Zero Flag (ZF) - 결과값이 0일때 1로 설정됩니다. 같은 레지스터끼리 아니면 같은 값을 가진 레지스터끼리 빼기를 하면 0이 되지요. 결과값이 0이 아닐경우 플래그 값은 0이됩니다.

- Sign Flag (SF) - 결과값이 음수일경우 1이 됩니다. 양수일때는 0이 되고요.

- Overflow Flag (OF) - 부호 있는 정수끼리의 연산에서 overflow일경우 1이 됩니다. 예를들어 100 + 50할 경우입니다.(결과값 범위가 -128...127이 아니므로) Carry Flag와는 다릅니다.

- Parity Flag (PF) - 비트값이 1인것이 짝수이면 1로 설정하고, 홀수이면 0으로 설정한다. 결과값이 word이고, 8 low bit이어도 분석을 한다.

- Auxiliary Flag (AF) - 부호 없는 정수 nibble(4 비트)이 overflow일경우 1로 설정한다.

- Interrupt enable Flag (IF) - CPU가 외부 장치에 의해 인터럽트를 반응할때 1로 설정한다.

- Direction Flag (DF) - 이 플래그는 명령어에 의해 data chain이 처리 될때 사용된다. 프로세싱이 메모리 앞 번지에서 뒷번지로 진행될때는 0로 설정되고 프로세싱이 메모리 뒷번지에서 앞번지로 진행 될때는 1로 설정된다.

## 연산:opcode
- test -  레지스터의 값은 바꾸지 않는 and. 플래그 레지스터값만 바뀐다.
- mul - 부호를 고려하지 않는 곱하기 (16비트 * 16비트 = 32비트 이므로 연산 시, 보이지 않는 레지스터를 추가로 사용함)
- imul - 부호를 생각하는 곱하기
